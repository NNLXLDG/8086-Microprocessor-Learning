#  8086 Microprocessor Learning 



第一章 汇编语言的基础知识
1、计算机系统概述
硬件（Handware）
软件（Software）
2、汇编语言介绍
3、数据表示
1. BCD码
2. ASCII码
3. 真值和机器数
4. 补码
4、8086微处理器
1、通用寄存器
2、标志寄存器FLAGS
3、指令指针IP
4、段寄存器
段超越前缀指令
计算机中信息的单位
数据的地址对齐
存储器(men)的分段管理
5、8086寻址方式
1、指令的组成
2、8086的机器代码格式
3、立即数寻址方式
4、存储器寻址方式
1. 直接寻址方式
2. 寄存器间接寻址方式
3. 寄存器相对寻址方式
4. 基址变址寻址方式
5. 相对基址变址寻址方式
5、寻址方式的多种表示方式
6、各种操作数的表达
第二章 8086指令系统
1、数据传送类指令
1. 传送指令MOV
2. 交换指令XCHG
3. 换码指令XLAT
4. 堆栈操作指令PUSH、POP
5. 标志传送指令
6. 标志位操作指令
7、地址传送指令
有效地址传送指令 LEA
指针传送指令 LDS 和 LES
2、算术运算类指令
1、加法指令ADD、ADC、INC
2、减法指令SUB、SBB、DEC
3、求补指令 NEG
4、比较指令CMP
5、乘法指令MUL、IMUL
6、除法指令DIV、IDIV
7、符号扩展指令CBW、CWD
8、十进制调整指令
压缩BCD码调整
非压缩BCD码调整
3、位操作指令
1、逻辑或指令 AND
2、逻辑与指令 OR
3、逻辑异或指令XOR
4、逻辑非指令 NOT
5、测试指令 TEST
6、移位指令（shift）
7、循环移位指令（rotate）
4、控制转移类指令
1、无条件转移指令 JMP
2、条件转移指令 JCC
3、循环指令（loop）
4、子程序指令
5、中断指令
5、处理机控制类指令
1、空操作指令 NOP
2、段超越前缀指令
3、封锁前缀指令 LOCK
4、暂停指令 HLT
5、交权指令 ESC
6、等待指令
第三章 汇编语言程序格式
1、汇编语言程序的开发
1、汇编语言程序设计的语句格式
2、汇编语言的程序格式
3、汇编语言的开发过程
4、DOS系统功能调用
功能调用的步骤
输入输出类调用
1、字符输出：
2、字符串输出：
3、字符输入：
4、字符串输入：
5、按键判断：
2、参量、变量和符号
1、参数
1. 常数
2. 数值表达式
3. 地址型参数
2、变量定义伪指令
1. 变量名
2. 位指令助记符
3. 初值表
3、变量和标号的属性
3、程序段的定义和属性
exe程序
com程序
1、简化段定义伪指令合集
.MODEL存储模型位指令
简化段定义伪指令
.STARTUP 程序开始伪指令
EXIT [返回参数] 程序终止伪指令
END [标号] 汇编结束伪指令
2、com程序的编写
3、完整段定义伪指令
完整段定义位指令
指定段寄存器伪指令
段组伪指令
段顺序伪指令
4、简化段定义格式的段属性
第四章 基本汇编语言程序设计
1、顺序程序设计
2、分支程序设计
1、单分支程序设计
2、双分支程序设计
3、多分支程序设计
3、循环程序设计
1、冒泡法
2、串操作类指令
4、 子程序设计
1、过程定义位指令
2、子程序的参数传递
3、子程序的嵌套
4、子程序的递归
5、子程序的重入
第五章 高级汇编语言程序设计
1、高级语言特性
1、条件控制伪指令
2、循环控制伪指令
3、过程声明和过程调用伪指令
2、宏结构程序设计
1、宏汇编
a. 宏
b. 宏指令
c. 宏展开
宏的参数
宏操作符
与宏有关的伪指令
宏汇编与子程序的比较
2、重复汇编
1. 按参数值重复
2. 按参数个数重复
3. 按参数字符个数重复
3、条件汇编
宏结构的作用
3、模块化程序设计
1. 源程序文件的包含
2. 目标代码文件的连接
3. 子程序库的调入
4、输入输出程序设计
1、 输入输出指令
a. 输入指令IN
b. 输出指令OUT
2、程序直接控制输入输出
3、程序查询输入输出
4、中断服务程序
内部中断服务程序
驻留中断服务程序
外部可屏蔽中断服务程序


## 一 预备

### 1.1 计算机中的数制

无符号数的表示方法：
1. 二进制数01  （两个数字）
2. 十进制数0～9   （十个数字）
3. 十六进制数0～9、A～F  （十六个数字）


各种数制之间的转换：
1. 非十进制数到十进制数的转换：按相应进位计数制的权表达式展开，再按十进制求和。
2. 十进制数制转换为二进制数制：整数部分除2取余；小数部分乘2取整。
3. 二进制与十六进制数之间的转换：用4位二进制数表示1位十六进制数


###  1.2 计算机中的码制
对于符号数，机器数常用的表示方法有原码、反码和补码三种。

注意：
1. 对正数，三种表示法均相同。
2. 它们的差别在于对负数的表示。

原码   
符号位：0 表示正，1 表示负；
数值位：真值的绝对值。
注意：数0 的原码不唯一

反码   
若X>0 ，则 [X]反=[X]原
若X<0， 则 [X]反= 对应原码的符号位不变，数值部分按位求反
注意：数0 的反码也不唯一

补码
定义：
若X>0， 则[X]补= [X]反= [X]原
若X<0， 则[X]补= [X]反+1
注意：机器字长为8 时，数0 的补码唯一，同为 00000000


8 位二进制的表示范围：
原码：-127~+127
反码：-127~+127
补码：-128~+127


特殊数10000000   
该数在原码中定义为： -0
在反码中定义为： -127
在补码中定义为： -128
对无符号数：(10000000)２ = 128


### 1.3 信息的编码

+ **十进制数的二进制数编码**：用4 位二进制数表示一位十进制数。有两种表示法：压缩 BCD 码和非压缩BCD 码。

   + 压缩BCD码的每一位用 4 位二进制表示，0000~1001 表示0~9，一个字节表示两位十进制数。
   +  非压缩BCD码用一个字节表示一位十进制数，高4 位总是0000，低4 位的0000~1001表示0~9

+ **字符的编码**：计算机采用7位二进制代码对字符进行编码
   + 数字0~9 的编码是0110000~0111001，它们的高3 位均是011，后4位正好与其对应的二进制代码（BCD 码）相符。
   + 英文字母A~Z 的ASCII 码从1000001（41H）开始顺序递增，字母 a~z 的ASCII 码从1100001（61H）开始顺序递增，这样的排列对信息检索十分有利。

## 二 微机组成原理


### 2.1 微机的结构

**计算机的经典结构——冯.诺依曼结构**
1. 计算机由运算器、控制器、输入设备和输出设备五大部分组成（**运算器和控制器又称为 CPU**）
2. 数据和程序以二进制代码形式不加区分地存放在存储器总，存放位置由地址指定，数制为二进制。
3. 控制器是根据存放在存储器中的指令序列来操作的，并由一个程序计数器控制指令的执行。


**系统总线的分类**
1. 数据总线（Data Bus），它决定了处理器的字长。
2. 地址总线（Address Bus）,它决定系统所能直接访问的存储器空间的容量。
3. 控制总线（Control Bus）

### 2.2 8086基本结构
+ 8086 是一种单片微处理芯片，其内部数据总线的宽度是 16 位，外部数据总线宽度也是16 位，片内包含有控制计算机所有功能的各种电路。
+ 8086 地址总线的宽度为 20 位，有1MB（2^20）寻址空间。
+ 8086CPU 由总线接口部件 BIU 和执行部件EU 组成。BIU 和EU 的操作是异步的，为8086 取指令和执行指令的并行操作体统硬件支持。

#### 2.2.1 寄存器


+ 通用寄存器
   - **通用数据寄存器（AX、BX、CX、DX）**：可用于暂存运算数据，参与算术和逻辑运算。AX（累加器）使用频率高，如乘法、除法等运算默认以AX为操作数或存放结果；BX可作基址寄存器，用于存储器寻址；CX常用于计数，如循环指令中自动计数；DX常配合AX进行乘除运算，存放高位数据。
   - **指针寄存器（BP、SP）**：BP（基址指针寄存器）用于访问堆栈段中的数据，常与SP配合获取堆栈中数据偏移地址；SP（堆栈指针寄存器）始终指向堆栈栈顶，用于控制堆栈操作，如入栈、出栈操作时自动调整指针。 
   - **变址寄存器（SI、DI）**：SI（源变址寄存器）、DI（目的变址寄存器）用于存储器寻址，在字符串操作等指令中，SI指向源操作数地址，DI指向目的操作数地址。 
+ 段寄存器（DS、ES、SS、CS ）
   - **DS（数据段寄存器）**：存放数据段的段基址，确定程序数据所在存储区域。
   - **ES（附加段寄存器）**：作为数据段补充，用于存储数据，在串操作等指令中可作为目的操作数所在段基址。 
   - **SS（堆栈段寄存器）**：存放堆栈段段基址，与SP配合管理堆栈空间。 
   - **CS（代码段寄存器）**：存放代码段段基址，与指令指针寄存器IP配合确定下一条要执行指令的地址。 
+ 专用寄存器
   - **IP（指令指针寄存器）**：始终指向下一条待执行指令在代码段内的偏移地址，与CS配合实现指令顺序执行及转移等操作。 
   - **FLAGS（状态标志寄存器）**：存放运算结果的状态标志（如进位标志CF、零标志ZF等）和控制标志（如中断允许标志IF等），反映运算结果特征及控制CPU操作。 


**FLAGS（状态标志寄存器）**

+ 状态标志：
   + 进位标志位（CF）：运算结果的最高位有进位或有借位，则CF=1
   + 辅助进位标志位（AF）：运算结果的低四位有进位或借位，则AF=1
   + 溢出标志位（OF）：运算结果有溢出，则 OF=1
   + 零标志位（ZF）：反映指令的执行是否产生一个为零的结果
   + 符号标志位（SF）：指出该指令的执行是否产生一个负的结果
   + 奇偶标志位（PF）：表示指令运算结果的低8 位“1”个数是否为偶数
+ 控制标志位
   + 中断允许标志位（IF）：表示CPU 是否能够响应外部可屏蔽中断请求
   + 跟踪标志（TF）：CPU 单步执行


#### 2.2.2 引脚及其功能
+ AD15~AD0：双向三态的地址总线，输入/输出信号
+ INTR：可屏蔽中断请求输入信号，高电平有效。可通过设置 IF 的值来控制。
+ NMI：非屏蔽中断输入信号。不能用软件进行屏蔽。
+ RESET：复位输入信号，高电平有效。复位的初始状态见P21
+ MN/MX：最小最大模式输入控制信号。




## 三 8086 指令系统

### 3.1 寻址方式

+ **立即寻址**   
   + 操作数(为一常数)直接由指令给出   
   + (此操作数称为立即数)   
   + 立即寻址只能用于源操作数   

+ **寄存器寻址**   
   + 操作数放在某个寄存器中   
   + 源操作数与目的操作数字长要相同    
   + 寄存器寻址与段地址无关    

+ **直接寻址**
   + 指令中直接给出操作数的16 位偏移地址 偏移地址也称为有效地址(EA, Effective Address)
   + 默认的段寄存器为DS，但也可以显式地指定其他段寄存器——称为段超越前缀
   + 偏移地址也可用符号地址来表示，如 ADDR、VAR

+ **间接寻址**
   + 操作数的偏移地址(有效地址EA)放在寄存器中
   + **只有SI、DI、BX和BP可作间址寄存器**
```
正确的
MOV AX,[BX]
MOV CL,CS:[DI]
错误的
MOV AX, [DX]
MOV CL, [AX]
```
+ **寄存器相对寻址**
    + EA=间址寄存器的内容加上一个 8/16 位的位移量
```
MOV AX, [BX+8]
MOV CX, TABLE[SI]
MOV AX, [BP]; 默认段寄存器为SS
```
+ 指令操作例：MOV AX，DATA[BX]
若(DS)=6000H, (BX)=1000H, DATA=2A00H,
(63A00H)=66H, (63A01H)=55H
则物理地址 = 60000H + 1000H + 2A00H = 63A00H
指令执行后：（AX）=5566H

+ **基址变址寻址**
若操作数的偏移地址：   
由基址寄存器(BX 或BP)给出 —— 基址寻址方式  
由变址寄存器(SI 或DI)给出 —— 变址寻址方式   
由一个基址寄存器的内容和一个变址寄存器的内容相加而形成操作数的偏移地址，称为基址-变址寻址。
```
EA=（BX）+（SI）或（DI）；
EA=（BP）+（SI）或（DI）
```
同一组内的寄存器不能同时出现。   
注意：除了有段跨越前缀的情况外，当基址寄存器为BX 时，操作数应该存放在数据段 DS中，当基址寄存器为 BP 时，操作数应放在堆栈段SS 中。
```
MOV AX, [BX][SI]
MOV AX, [BX+SI]
MOV AX, DS: [BP][DI]
```

**相对基址变址寻址**
在基址-变址寻址的基础上再加上一个相对位移量    
EA=（BX）+（SI）或（DI）+8 位或16 位位移量；

```
MOV AX，DATA[DI][BX]
```
若(DS)=8000H, (BX)=2000H, (DI)=1000H, DATA=200H
则指令执行后(AH)=[83021H], (AL)=[83020H]


###  3.2 数据传送指令

#### 3.2.1 通用传送指令

##### MOV指令
MOV dest，src； dest←src
传送的是字节还是字取决于指令中涉及的寄存器是8位还是16位。
具体来说可实现：
1. MOV mem/reg1，mem/reg2
指令中两操作数中至少有一个为寄存器
2. MOV reg，data ;立即数送寄存器
3. MOV mem，data ;立即数送存储单元
4. MOV acc，mem ;存储单元送累加器
5. MOV mem，acc ;累加器送存储单元
6. MOV segreg，mem/reg ;存储单元/寄存器送段寄存器
7. MOV mem/reg，segreg ;段寄存器送存储单元/寄存器



**MOV 指令的使用规则**
1. IP 不能作目的寄存器  
2. 不允许mem←mem
3. 不允许segreg←segreg（段寄存器）
4. 立即数不允许作为目的操作数
5. 不允许segreg←立即数
6. 源操作数与目的操作数类型要一致
7. 当源操作数为**单字节**的立即数，而目的操作数为间址、变址、基址+变址的内存数时，必须用PTR 说明数据类型。如：MOV [BX]，12H 是错误的。


##### 压栈指令PUSH
PUSH src ; src 为16 位操作数

PUSH AX ；将AX 内容压栈  
执行操作：（SP）-1←高字节AH   
（SP）-2←低字节AL    
(SP)←（SP）- 2    
注意进栈方向是高地址向低地址发展。   


##### 弹出指令POP
POP dest

POP BX ；将栈顶内容弹至BX    
执行操作：（BL）←（SP）    
（BH）←（SP）+1    
（SP）←（SP）+2    
堆栈指令在使用时需注意的几点：    
1. 堆栈操作总是按字进行    
2. 不能从栈顶弹出一个字给CS
3. 堆栈指针为SS:SP，SP 永远指向栈顶
4. SP自动进行增减量（-2，+2）

##### 交换指令XCHG

格式：XCHG reg，mem/reg
功能：交换两操作数的内容。
要求：两操作数中必须有一个在寄存器中；
操作数不能为段寄存器和立即数；
源和目地操作数类型要一致。
举例： XCHG AX，BX
XCHG [2000]，CL


##### 查表指令XLAT
执行的操作：AL←[(BX)+(AL)]
又叫查表转换指令，它可根据表项序号查出表中对应代码的内容。执行时先将表的首地址
（偏移地址）送到BX 中，表项序号存于 AL 中。